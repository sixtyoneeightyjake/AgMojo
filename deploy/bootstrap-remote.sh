#!/usr/bin/env bash
set -euo pipefail

# Bootstrap a production deployment on a fresh Ubuntu/Debian server.
# - Installs Docker + Docker Compose plugin
# - Creates dedicated user and directories
# - Clones this repo to /opt/agentmojo
# - Writes .env for docker-compose variable substitution
# - Brings up the stack bound to 127.0.0.1:3000
# - Installs/Configures Nginx + TLS (optional) and Basic Auth (optional)
# - Installs a systemd unit and helper commands
#
# Required env vars:
#   DOMAIN                      e.g. example.com
#   VITE_SUPABASE_URL           e.g. https://your-project.supabase.co
#   VITE_SUPABASE_ANON_KEY      Supabase anon key
#   SUPABASE_URL                same as VITE_SUPABASE_URL (backend)
#
# Optional env vars:
#   REPO_URL                    default: current repo upstream or https
#   BRANCH                      default: main
#   ADMIN_EMAIL                 Certbot email; enables automatic HTTPS if set
#   BASIC_AUTH_USER             default: admin (if set, enables basic auth)
#   BASIC_AUTH_PASSWORD         default: randomly generated if not provided
#   OPENAI_API_KEY              if needed by your config
#   SANDBOX_RUNTIME_CONTAINER_IMAGE default used if not provided
#

if [[ $EUID -ne 0 ]]; then
  echo "Please run as root (sudo)" >&2
  exit 1
fi

APP_USER=${APP_USER:-agentmojo}
APP_DIR=${APP_DIR:-/opt/agentmojo}
SERVICE_NAME=${SERVICE_NAME:-agentmojo}

# Required inputs
DOMAIN=${DOMAIN:-}
VITE_SUPABASE_URL=${VITE_SUPABASE_URL:-}
VITE_SUPABASE_ANON_KEY=${VITE_SUPABASE_ANON_KEY:-}
SUPABASE_URL=${SUPABASE_URL:-$VITE_SUPABASE_URL}

if [[ -z "$DOMAIN" || -z "$VITE_SUPABASE_URL" || -z "$VITE_SUPABASE_ANON_KEY" || -z "$SUPABASE_URL" ]]; then
  echo "Missing required env. Set: DOMAIN, VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, SUPABASE_URL" >&2
  exit 2
fi

REPO_URL=${REPO_URL:-https://github.com/sixtyoneeighty/AgMojo.git}
BRANCH=${BRANCH:-main}
ADMIN_EMAIL=${ADMIN_EMAIL:-}
BASIC_AUTH_USER=${BASIC_AUTH_USER:-}
BASIC_AUTH_PASSWORD=${BASIC_AUTH_PASSWORD:-}

echo "[1/8] Installing Docker and prerequisites..."
apt-get update -y
apt-get install -y ca-certificates curl gnupg lsb-release
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
chmod a+r /etc/apt/keyrings/docker.gpg
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") \
  $(. /etc/os-release; echo "$VERSION_CODENAME") stable" | \
  tee /etc/apt/sources.list.d/docker.list >/dev/null
apt-get update -y
apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin git nginx apache2-utils
systemctl enable --now docker

echo "[2/8] Creating app user and directories..."
if ! id "$APP_USER" >/dev/null 2>&1; then
  useradd -m -s /bin/bash "$APP_USER"
fi
usermod -aG docker "$APP_USER"
mkdir -p "$APP_DIR" "$APP_DIR/workspace" "/home/$APP_USER/.openhands"
chown -R "$APP_USER:$APP_USER" "$APP_DIR" "/home/$APP_USER/.openhands"

echo "[3/8] Cloning repository..."
if [[ ! -d "$APP_DIR/.git" ]]; then
  sudo -u "$APP_USER" git clone --branch "$BRANCH" --depth 1 "$REPO_URL" "$APP_DIR"
else
  echo "Repo already present; pulling latest..."
  sudo -u "$APP_USER" git -C "$APP_DIR" fetch --depth 1 origin "$BRANCH"
  sudo -u "$APP_USER" git -C "$APP_DIR" checkout "$BRANCH"
  sudo -u "$APP_USER" git -C "$APP_DIR" reset --hard "origin/$BRANCH"
fi

echo "[4/8] Writing environment (.env) and compose overrides..."
ENV_FILE="$APP_DIR/.env"
cat > "$ENV_FILE" <<EOF
# Autogenerated by bootstrap-remote.sh
DOMAIN=$DOMAIN
VITE_SUPABASE_URL=$VITE_SUPABASE_URL
VITE_SUPABASE_ANON_KEY=$VITE_SUPABASE_ANON_KEY
SUPABASE_URL=$SUPABASE_URL
# Runtime selection (default to E2B for remote sandboxes)
RUNTIME=${RUNTIME:-e2b}
# E2B API key (required if using E2B runtime)
E2B_API_KEY=${E2B_API_KEY:-}
SANDBOX_RUNTIME_CONTAINER_IMAGE=
OPENAI_API_KEY=${OPENAI_API_KEY:-}
EOF
chown "$APP_USER:$APP_USER" "$ENV_FILE"
chmod 600 "$ENV_FILE"

echo "[5/8] Bringing up containers (127.0.0.1:3000)..."
sudo -u "$APP_USER" env -C "$APP_DIR" bash -lc \
  'set -euo pipefail; \
   export $(grep -v "^#" .env | xargs -d "\n" -n1); \
   docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build'

echo "[6/8] Configuring Nginx as reverse proxy..."
SITE_CONF="/etc/nginx/sites-available/$DOMAIN"
WS_MAP="/etc/nginx/conf.d/websocket.conf"
cat > "$WS_MAP" <<'WSMAP'
map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}
WSMAP

cat > "$SITE_CONF" <<NGINX
server {
    listen 80;
    server_name $DOMAIN;
    client_max_body_size 50m;

    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_read_timeout 600s;
        proxy_send_timeout 600s;
    }

    # Optional Basic Auth
    # auth_basic "Restricted";
    # auth_basic_user_file /etc/nginx/.htpasswd;
}
NGINX

ln -sf "$SITE_CONF" "/etc/nginx/sites-enabled/$DOMAIN"
nginx -t
systemctl reload nginx

if [[ -n "$ADMIN_EMAIL" ]]; then
  echo "[7/8] Enabling HTTPS with Letâ€™s Encrypt..."
  apt-get install -y certbot python3-certbot-nginx
  certbot --nginx -d "$DOMAIN" --redirect -m "$ADMIN_EMAIL" --agree-tos -n || true
fi

if [[ -n "$BASIC_AUTH_USER" ]]; then
  echo "[7b/8] Enabling Basic Auth..."
  : "${BASIC_AUTH_PASSWORD:=$(tr -dc A-Za-z0-9 </dev/urandom | head -c 20)}"
  htpasswd -B -b -c /etc/nginx/.htpasswd "$BASIC_AUTH_USER" "$BASIC_AUTH_PASSWORD"
  sed -i 's/# auth_basic /auth_basic /' "$SITE_CONF" || true
  sed -i 's/# auth_basic_user_file /auth_basic_user_file /' "$SITE_CONF" || true
  nginx -t && systemctl reload nginx
  echo "Basic auth enabled for user: $BASIC_AUTH_USER"
fi

echo "[8/8] Installing systemd unit and helpers..."
UNIT_FILE="/etc/systemd/system/${SERVICE_NAME}.service"
cat > "$UNIT_FILE" <<EOF
[Unit]
Description=AgentMojo service
After=docker.service network.target
Requires=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
User=$APP_USER
WorkingDirectory=$APP_DIR
EnvironmentFile=$APP_DIR/.env
ExecStart=/usr/bin/docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build
ExecStop=/usr/bin/docker compose -f docker-compose.yml -f docker-compose.prod.yml down
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable --now "$SERVICE_NAME"

cat > /usr/local/bin/${SERVICE_NAME}-status <<'EOS'
#!/usr/bin/env bash
set -e
systemctl status agentmojo --no-pager || true
sudo -u agentmojo env -C /opt/agentmojo docker compose -f docker-compose.yml -f docker-compose.prod.yml ps
EOS
chmod +x /usr/local/bin/${SERVICE_NAME}-status

cat > /usr/local/bin/${SERVICE_NAME}-logs <<'EOS'
#!/usr/bin/env bash
sudo -u agentmojo env -C /opt/agentmojo docker compose -f docker-compose.yml -f docker-compose.prod.yml logs -f --tail=200 "$@"
EOS
chmod +x /usr/local/bin/${SERVICE_NAME}-logs

cat > /usr/local/bin/${SERVICE_NAME}-update <<'EOS'
#!/usr/bin/env bash
set -euo pipefail
sudo -u agentmojo bash -lc '
  set -e
  cd /opt/agentmojo
  git fetch --depth 1 origin
  git rev-parse --abbrev-ref HEAD | xargs -I{} git reset --hard origin/{}
  export $(grep -v "^#" .env | xargs -d "\n" -n1)
  docker compose -f docker-compose.yml -f docker-compose.prod.yml pull || true
  docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build
'
systemctl restart agentmojo || true
EOS
chmod +x /usr/local/bin/${SERVICE_NAME}-update

echo
echo "Deployment complete. Next steps:"
echo "- Verify local app: curl -I http://127.0.0.1:3000"
echo "- Visit: https://$DOMAIN (HTTP will redirect if certbot ran)"
if [[ -n "$BASIC_AUTH_USER" ]]; then
  echo "- Basic auth user: $BASIC_AUTH_USER (password was provided${BASIC_AUTH_PASSWORD:+/generated})"
fi
echo "- Manage: ${SERVICE_NAME}-status | ${SERVICE_NAME}-logs | ${SERVICE_NAME}-update"
echo
